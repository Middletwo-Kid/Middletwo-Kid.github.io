> JS是一门 单线程 非阻塞 语言。

## 队列

- 队列：主要特点是先进先出，就好像你在排队的时候，后面来的人出排在队尾，每次对头的人打饭完就先走了。

## 单线程机制

单线程就是**同一个时间只能做一件事情**。

`JavaScript`的主要作用是与用户互动，以及操作DOM。假设`Javascript`是两（多）线程，在同一个时间内，一个线程在某个DOM上添加内容，一个线程删除这个节点，这时浏览器以哪个线程为准？所以**JS是一门单线程语言**。

`JavaScript`在运行的时候，会开始处理队列中最先进入的任务，处理过的任务就会被移除队列。一个函数的调用总会为其创造一个新的栈，函数的处理会等待执行栈为空为止，然后事件循环就会处理队列中的下一个任务。这种机制的优点就是：每个任务完整地执行之后，其他任务才会被执行。即当一个函数被执行的时候，只有它运行完毕之后才会去运行其他代码，才可以修改这个函数操作的数据。

缺点在于：当一个消息需要太长时间才能处理完毕时，Web应用程序就无法处理与用户的交互。

## 同步和异步任务

为了解决单线程引起的等待处理时间过长的缺点，JS中有了同步和异步任务。

### 同步任务

```js
console.log(1);  
console.log(2);  

// 打印结果依次为： 1 2
```

打印函数依次进入消息队列，然后先进先出，这就是同步任务。

### 异步任务

```js
setTimeout(() => {
    console.log(1);
}, 0);
console.log(2);

// 打印结果依次为： 2 1
```

DOM操作、`setTimeout`、`ajax`等都是异步任务，他们的执行顺序不满足先进先出。

## 事件循环的过程

1. 所有的同步任务都在主线程上执行，形成一个执行栈；
2. 主线程之外，还存在一个消息（任务）队列，主要异步操作执行完成，就到消息队列中排队；
3. 一旦执行栈中所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行它的回调函数；
4. 主线程不断重复上面的第三步。

举个栗子：

```js
console.log(1);
setTimeout(() => {
    console.log(2);
}, 0)

console.log(3);
setTimeout(() => {
    console.log(4);
}, 0)

// 打印结果依次为： 1 3 2 4
```

执行过程是这样的，我们拥有一个主线程和一个消息队列，主线程存放的是同步任务，消息队列存放的是异步任务：

- 执行`console.log(1);`，它是一个同步任务，就打印了1；
- 执行`setTimout`，它是一个异步任务，我们在同步执行主线程的任务的时候，会同时执行它并得到结果，但是是会推入消息队列，这时推入的结果是2；
- 执行`console.log(3);`，它是一个同步任务，就打印了3；
- 执行`setTimout`，它是一个异步任务，我们在同步执行主线程的任务的时候，会同时执行它并得到结果，但是是会推入消息队列，这时推入的结果是4；
- 此时主线程的任务已经清空了，控制台已经打印出了`1 3`；此时就依次读取消息队列中的任务，将第一个`setTimeout`推入主线程中，

> 函数 `setTimeout` 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，`setTimeout` 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。

## 宏观任务和微观任务

异步任务分为宏观任务和微观任务，

宏观任务有`setInterval`、`setTimeout`、`setImmediate`；

微观任务有`promise`。

**微任务永远执行在宏任务之前**。

```js
console.log(1);
setTimeout(() => {
    console.log(2);
})
new Promise((resolve, reject) => {
    console.log(3);
    resolve(4);
}).then(res => {
    console.log(res);
})

// 打印结果依次为： 1 3 4 2
```

- 执行`console.log(1);`，它是一个同步任务，就打印了1；
- 执行`setTimeout`，它是一个异步任务，我们在同步执行主线程的任务的时候，会同时执行它并得到结果，但是是会推入**宏观**消息队列，这时推入的结果是2；
- 执行`promise`，打印3，然后遇到了`resolve`，是一个异步函数，执行得到4，推入**微观**消息队列；
- 此时主线程已经空了，所以执行消息队列的内容，先执行微观消息队列，打印出4；
- 微观消息队列为空了，再执行宏观消息队列，打印2。

**执行宏观任务的过程中如果遇到微观任务，就先执行完内部的微观任务再执行下一个宏观任务。**

```js
console.log('global')

for (var i = 1;i <= 5;i ++) {
  setTimeout(function() {
    console.log(i)
  },i*1000)
  console.log(i)
}

new Promise(function (resolve) {
  console.log('promise1')
  resolve()
 }).then(function () {
  console.log('then1')
})

setTimeout(function () {
  console.log('timeout2')
  new Promise(function (resolve) {
    console.log('timeout2_promise')
    resolve()
  }).then(function () {
    console.log('timeout2_then')
  })
}, 1000)

// global
// 1
// 2
// 3
// 4
// 5
// promise1
// then1
// 6
// timeout2
// timeout2_promise
// timeout2_then
// 6
// 6
// 6
// 6
```

- `console.log('global')`同步任务；
- 依次将`setTimeout`推入宏观队列，并打印`i`;
- 打印`promise1`，并将`console.log('then1')`推入微观队列；
- 将`setTimeout`推入宏观队列；
- 任务队列已经空了，执行微观对了，打印`then1`；
- 执行宏观队列第一个`setTimeout`，它的时间间隔是1000， 打印6；
- 执行第一个`setTimeout`， `console.log('timeout2')`打印`timeout2`, 打印`timeout2_promise`，将`timeout2_then`推入微观队列；
- 第二个宏观任务执行完毕，微观队列有任务，执行微观对了，打印`timeout2_then`；
- 微观队列空了，继续执行宏观队列~

## 小结

JS是单线程机制，确保了`JS`在同一时间只执行一个事件，独特的事件循环确保了单线程机制，任务执行不会被阻塞。

事件循环机制如下：

- 遇到同步事件立即执行，如果遇到异步事件推入消息队列中；
- 当同步事件全部执行完毕，开始执行消息队列，先执行消息队列中的微观任务，如`promise`；
- 微观任务队列执行完毕之后被清空后，执行宏观任务队列；
- 执行一个宏观任务的过程中如果遇到微观任务就推入微观队列中，
- 当这个宏观任务执行完毕之后，如果微观任务队列有任务就执行微观任务，如果没有，才执行下一个宏观任务。

常见的宏观任务有`setInterval`、`setTimeout`、`setImmediate`、`I/O`、` UI rendering`；

微观任务有`promise`、`process.nextTick`、` Object.observe`、`MutationObserver`。